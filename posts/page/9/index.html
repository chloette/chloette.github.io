<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>Posts :: 你好，世界 — 📝🎿🛹🏍️</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/" />


<link rel="stylesheet" href="/assets/style.css">


<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>



<meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />

<meta property="og:updated_time" content="2019-07-28T23:01:43&#43;08:00"/><meta property="og:site_name" content="你好，世界" />



<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="你好，世界" />



  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" width="44" height="44" viewBox="0 0 44 44">
  <polyline fill="none" stroke="#000" stroke-width="2" points="15 8 29.729 22.382 15 35.367"/>
</svg>
</span>
    <span class="logo__text">Hello World</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  <div class="posts">
    
    
    

    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/about-weixin-and-alipay/">谈谈微信和支付宝</a></h1>
      <div class="post-meta">
        <span class="post-date">
          2015-01-22
        </span>
        <span class="post-author">— Written by Guo Yi</span>
        
      </div>


      
        <span class="post-tags">
          
            #<a href="/tags/%E8%AE%B0%E5%BD%95/">记录</a>&nbsp;
          
            #<a href="/tags/%E5%BE%AE%E4%BF%A1/">微信</a>&nbsp;
          
        </span>
      

      

      <div class="post-content">
        
          
            一月初的时候，微信推出了JS SDK，增加了如下接口：
 分享类接口 图像类接口 音频类接口 智能类接口 设备信息类接口 地理位置类接口 界面操作类接口 微信扫一扫接口 微信小店接口 微信卡券接口 微信支付接口  看起来能做的事情不少啊，这让不少移动前端的同学感慨是否要转型html5+js了。。。
我想说这其实完全不是一个新问题。
因为微信很早以前就开始布局了，从他开放sdk那天开始。
微信开放JS SDK，不能算是多大的跨越，只能说是再进一步；即对于公众号/服务号就可以满足需要的应用（主要是生活服务类，例如银行啊，快递啊，吃穿住用啊）来说，不需要火急火燎的开发android/iOS/WP对应的客户端了，只要网页端接口调用和优化到位，依托微信的支持，开发更快（生活服务类的应用普遍有配套网站，现成的JS码农），效果更好（废话啊），而且使用量（专业点是不是该叫“日活”？哈哈哈）很可能会比自己独立开发的app还要高的多。
话说现在才有这个担心的同学们，你们是不是太后知后觉了点？
已经在做html5+js的同学们，你们注意啦，以后竞争压力只会越来越大。
会有人疑问，是不是大一统时代到来了啊？（其实html5刚出来的时候，这种呼声就层出不穷）怎么说那，就是让浏览器搞定所有事，例如浏览器可以看电影，可以听音乐，可以看新闻，可以聊八卦，可以购物，可以分享，可以下载，甚至还可以玩3D游戏&hellip;试问对于一个普通人，一台电脑装一个浏览器不就够了么？
这个疑问，多少会让人想起90年代微软和网景（神马？你不知道这个公司？很正常，哈哈哈）的撕逼大战。结果嘛，很明显，你看现在还多少人知道网景这个公司？
那时候受制于各种因素（硬件对渲染能力的限制，操作系统对权限的限制，网络基础带宽的限制等等），浏览器的capability完全无法满足用户的需要。所以那场撕逼大战的胜利要素就是浏览器单价；对，那时候的浏览器，作为一个app，是需要花钱买的。。。所以微软心一横，直接捆绑在windows里面，送给用户。尽管后来因此被告涉嫌垄断，被巨额罚款并且还要拆分公司，但微软的IE一度达到市占率90%！好吧扯淡到此为止。
继续说，而现在，随着Chrome等一众浏览器的兴起，加上html5（你丫不就加了几个tag么）的推波助澜，大一统说法不仅仅只是停留在讨论的层面，Google甚至还顺势推出了Chrome笔记本（尽管雷声大雨点小）。。。
在我看来，这一切，又仿佛回到了若干年前，那个从Rich Client向Thin Client过渡的时代。其实归根结底，还是要看基础带宽和基础硬件的性能瓶颈。
当基础带宽不够，基础硬件跟不上的时候；那就把脏活累活都扔到带宽够硬件强大的服务器去做吧；当基础带宽和硬件渐渐跟上，自然也可以把一部分工作放回本地（电脑/手机/平板）来处理；随着基础带宽和硬件的不断进化，服务器和本地的差别也就越来越小；是服务器来处理，还是本地来处理，甚至可以采用动态均衡的方式（网游普遍用类似的策略来避免突发延迟带来的卡顿）；Rich client和Thin client这种泾渭分明的标签，已经不适合我们的时代了。
现在，3G/4G已经可以轻松支持高清视频在线播放；Face Time及类似App提供的更直观的通话方式，让传统电信运营商压力倍增；
现在手机/平板的运算速度/内存大小，甚至已经超过了很多人的家用电脑；
曾经，对于一个普通人来说，手机需要同时安装浏览器，QQ，淘宝，京东，支付宝，打车软件，大众点评，各类手机银行等等等等；
现在，手机只要有微信就够了；
随着接口的不断开放，协议/标准的不断完善，云服务对过往常规本地服务的不断优化改进；操作系统/浏览器/App彼此的功能交叉覆盖越来越多，彼此的界限也越来越模糊（现在已经不能简单的说微信只是一个社交软件了吧）。
大一统的赶脚有木有？
有了这些铺垫，再回过头来，说说微信和支付宝在做的事情。
微信和支付宝，两者出发点不同，但都在尽全力扩大自己的入口优势并提高用户粘性。
不说枯燥的功能点，这里举个生活中具体的例子：
下班了，要和朋友去吃饭；
 打开手机某App，点开某美食公众号，它根据我的坐标帮我推荐了旁边一家餐厅，我确认后它还帮我在线排队； 不错，估计走到地方就差不多可以吃了，到地方的途中刷刷朋友圈； 落座，点餐前餐厅服务员说关注他们家的公众号可以打折并享受免费WIFI；关注后发现了一些新菜品，点之； 等上菜的时候朋友分享我一个数码新品，看起来蛮有意思的，下单买之，妥妥的次日达； 吃饭前比个剪刀手拍个照（真是恶俗啊。。）上传朋友圈； 吃完饭结账，服务员说手机付款还有额外折扣，便宜了很多； 出了餐厅，用手机打车各回各家，打车还有红包可以用；  如何，一台手机一个应用，手指抖抖就搞定所有生活细节，是不是很方便？这其实就是目前一线城市（非地域党，但一线城市对移动互联网的推广和完善力度毋庸置疑）很多年轻人的生活方式；很多二三线城市也在被快速接受的生活方式。
现在很多人用微信来做1/2/3/4/5/7；用支付宝来做6/7；而实际上，目前最新版本的微信和支付宝，都可以基本实现上述所有功能。（微信和支付宝的差异这里就不展开了，都在用的东西谁都能说出个一二来）
微信对JS SDK的放开，就是在进一步加强对支付环节的控制。
而支付宝新版本的功能强化，就是对公众号/朋友圈功能的补全。
撕逼大战再次展开（我看好微信哦）～
所谓的大一统，也许浏览器尚未完成的事情，要交给带有支付属性的社交软件来完成了。
想象一下，一个普通的饭店，不需要自己购买POS机（也许一个二维码就够了），不需要自己去铺设高速WIFI，不需要请码农不需要请美工，不需要租借服务器，只要付出也许一周甚至几天的流水（作为年费），就可以跻身移动互联网的浪潮中，可以在线订外卖，在线排队，在线点餐，全店覆盖免费WIFI，在线支付，在线获取吃客反馈；可以鼠标点点就将新菜新优惠等通知到本店拥趸吃货手中；而互联网的及时效应，会以良性循环的方式不断推动这家饭店，保证新鲜食材，保证质量，提高服务态度等等（小心差评哦）。
而这种生活，这种方式，这种正向推动，才是未来；才是互联网，应该做的。
有木有发现一件事情；
入口的变化：桌面端操作系统 -&gt; 桌面端浏览器 -&gt; 移动端操作系统 -&gt; 微信/支付宝；
而码农们需要做的事情：跨平台(Windows/Linux) -&gt; 跨浏览器（IE6，哈哈哈） -&gt; 跨平台（Android/IOS/WP） -&gt; 跨App（微信接口和支付宝接口）；
          
        
      </div>
      <div><a class="read-more button" href="/posts/about-weixin-and-alipay/">Read more →</a></div>
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/script-to-modify-ghost-screen-css/">Ghost修改screen.css的脚本</a></h1>
      <div class="post-meta">
        <span class="post-date">
          2015-01-21
        </span>
        <span class="post-author">— Written by Guo Yi</span>
        
      </div>


      
        <span class="post-tags">
          
            #<a href="/tags/ghost/">ghost</a>&nbsp;
          
            #<a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>&nbsp;
          
            #<a href="/tags/script/">script</a>&nbsp;
          
            #<a href="/tags/python/">python</a>&nbsp;
          
        </span>
      

      

      <div class="post-content">
        
          
            Ghost更新越来越频繁，每次都要手动更新css实在伤不起。。。
反正改动的地方也不多，干脆做成一键脚本好了，把之前upgrade的脚本再扩展一下：
首先更改#7，改动如下，增加了change logo position：
#change post page what to show&hellip; echo &lsquo;7. replace &quot;excerpt&quot; with &quot;content&quot; &mdash;&mdash;&mdash;&mdash;&mdash;&rsquo; #excerpt -&gt; content #read more -&gt; &gt;&gt; sed -i &quot;s#&lt;p&gt;{{excerpt words=&amp;quot;26&amp;quot;}} &lt;a class=&amp;quot;read-more&amp;quot; href=&amp;quot;{{url}}&amp;quot;&gt;&amp;raquo;#&lt;p&gt;{{content words=&amp;quot;32&amp;quot;}} &lt;a class=&amp;quot;read-more&amp;quot; href=&amp;quot;{{url}}&amp;quot;&gt;&amp;amp;raquo;&amp;amp;raquo;#g&quot; ./content/themes/casper/partials/loop.hbs #change logo position sed -i &rsquo;s~{{#if @blog.logo}}&lt;a class=&quot;blog-logo&quot; href=&quot;{{@blog.url}}&quot;&gt;&lt;img src=&quot;{{@blog.logo}}&quot; alt=&quot;Blog Logo&quot; /&gt;&lt;/a&gt;{{/if}}~~g&rsquo; ./content/themes/casper/index.hbs sed -i &rsquo;s~&lt;h1 class=&quot;page-title&quot;&gt;{{@blog.title}}&lt;/h1&gt;~{{#if @blog.logo}}&lt;a class=&quot;blog-logo&quot; href=&quot;{{@blog.url}}/about&quot;&gt;&lt;img src=&quot;{{@blog.logo}}&quot; alt=&quot;Blog Logo&quot; /&gt;&lt;/a&gt;{{/if}}&lt;h1 class=&quot;page-title&quot;&gt;{{@blog.title}}&lt;/h1&gt;~g&rsquo; ./content/themes/casper/index.hbs  再就是考虑到自己智商太低，难以驾驭sed的多行匹配，所以祭出Python；脚本中加上这句：
#call python to do multiple lines replacement python ~/ghost_css_adjustment.
          
        
      </div>
      <div><a class="read-more button" href="/posts/script-to-modify-ghost-screen-css/">Read more →</a></div>
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/android-imagefetcher/">Android ImageFetcher</a></h1>
      <div class="post-meta">
        <span class="post-date">
          2015-01-21
        </span>
        <span class="post-author">— Written by Guo Yi</span>
        
      </div>


      
        <span class="post-tags">
          
            #<a href="/tags/android/">Android</a>&nbsp;
          
            #<a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>&nbsp;
          
            #<a href="/tags/imagefetcher/">ImageFetcher</a>&nbsp;
          
        </span>
      

      

      <div class="post-content">
        
          
            Google完善文档后，也提供了一大批优秀的源代码。
ImageFetcher就是其中之一，这货非常简洁的实现了用ImageView来异步加载网页图片，同时对图片进行二级缓存的功能。
稍微改改就可以轻松适配任何图片资源（例如本地，例如需特殊条件（如宽高，比例，透明度等）等）了。
主体代码构成： 外部调用如下：
 New：
ImageFetcher imageFetcher = new ImageFetcher(context, width, height);  就可以了。
当然这里一般都会改动；
例如为了区分cache目录，会把unique folder name作为参数传入进去）。
例如为了替换默认图，把图标传进去。
例如为了适配任何图片资源，增加自定义的ImageProvider，也在初始化的时候传进去。
 Load bitmap：   imageFetcher.loadImage(pathString, (ImageView) view.findViewById(R.id.thumbnail));   这样这个ImageView就会在图片通过异步下载好（并缓存）以后，自己加载显示出来了～
 Close cache：  imageFetcher.setPauseWork(false); imageFetcher.closeCache();  就是这么简单任性～
内部逻辑重点的几个：
 对Download下来的图片，使用DiskLruCache来本地缓存，使用LruCache作为内存缓存；
 使用AsyncTask（WeakReference）来异步download图片；结束后对ImageView（WeakReference）进行setImageDrawable（AsyncDrawable）；这里的AsyncDrawable内部有正在处理自身的AsyncTask的WeakReference，所以可以避免重复execute的情况；每次都会先cancel之前的。
 AsyncTask跑在Executor（线程池）中。
  主要原理就是这样，其中一些细节可以自己翻源码～～ 非常方便使用和扩展～ 基本已经成为搭项目时必备库之一。
但是这里有一点，需要注意！
谨慎使用ImageFetcher.setPauseWork
官方Sample给出了两个用法，看起来前后有一点矛盾：
一个是在Grid滑动的时候：
public void onScrollStateChanged(AbsListView absListView, int scrollState) { // Pause fetcher to ensure smoother scrolling when flinging if (scrollState == AbsListView.
          
        
      </div>
      <div><a class="read-more button" href="/posts/android-imagefetcher/">Read more →</a></div>
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/ec2-devxvda1-should-be-checked-for-errors/">EC2 /dev/xvda1 should be checked for errors</a></h1>
      <div class="post-meta">
        <span class="post-date">
          2015-01-20
        </span>
        <span class="post-author">— Written by Guo Yi</span>
        
      </div>


      
        <span class="post-tags">
          
            #<a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>&nbsp;
          
            #<a href="/tags/ec2/">EC2</a>&nbsp;
          
        </span>
      

      

      <div class="post-content">
        
          
        
      </div>
      <div><a class="read-more button" href="/posts/ec2-devxvda1-should-be-checked-for-errors/">Read more →</a></div>
    </div>
    
    <div class="post on-list">
      <h1 class="post-title"><a href="/posts/proguard-obfuscation/">Proguard混淆</a></h1>
      <div class="post-meta">
        <span class="post-date">
          2015-01-17
        </span>
        <span class="post-author">— Written by Guo Yi</span>
        
      </div>


      
        <span class="post-tags">
          
            #<a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>&nbsp;
          
            #<a href="/tags/proguard/">proguard</a>&nbsp;
          
            #<a href="/tags/%E6%B7%B7%E6%B7%86/">混淆</a>&nbsp;
          
        </span>
      

      

      <div class="post-content">
        
          
            这里仅仅说Android的混淆，其他平台基本相同。
不同的IDE有不同的配置方法。
Android Studio的配置略有差异，可以参考前文
混淆的大致原理就是rename class（所以混淆的过程比较慢），混淆的初衷，并不是为了不让人看源码，毕竟java的虚拟机机制就决定了，源码肯定是可以反编译出来的；其主要目的是让反编译后的代码“难以”看懂。
例如打开一个混淆后输出的mapping文件，可以看到：
（某代码片段，请无视。）
这样一来，反编译后的代码里面，基本就是a.b.c(d.e)这种代码（也许原来只是Util.isNetworkAvailable(context)），大大增加了阅读难度；也就达到了防止反编译的目的。
但经常会误伤，因为是rename，所以对name敏感（依赖name）的方法或者库就会无法正常工作。例如反射，例如JNI的接口class（依赖class name来找context object），例如GSON这些常用工具库。
解决办法就是修改proguard的配置文件，将这些敏感class置为例外。
常用方法如下：
 排除指定类A
-keepclassmembers class com.xxx.xxx.A { *; }   将类A的子类全部排除 language-bash -keepclassmembers class * extends com.xxx.xxx.A { <em>; }   将包P内的class全部排除
-keep public class com.xxx.P.</em> { *; }   将包P内的class及subclass全部排除 language-bash -keep public class com.xxx.P.** { *; }     注意*和**的差别；
注意最后的{ *; }，用法很多，可以指定仅排除public/protected，如：
{ public protected *;}  当然还可以直接更直接一些：
{ &lt;fields&gt;; &lt;methods&gt;; }  如果是使用Gson的话，还可以直接如下使用方式来避免混淆问题：
          
        
      </div>
      <div><a class="read-more button" href="/posts/proguard-obfuscation/">Read more →</a></div>
    </div>
    
    <div class="pagination">
  <div class="pagination__buttons">
    
      <span class="button previous">
        <a href="/posts/page/8/">
          <span class="button__icon">←</span>
          <span class="button__text">Newer posts</span>
        </a>
      </span>
    
    
      <span class="button next">
        <a href="/posts/page/10/">
          <span class="button__text">Older posts</span>
          <span class="button__icon">→</span>
        </a>
      </span>
    
  </div>
</div>

  </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">来自某个八零后</div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
  </body>
</html>
