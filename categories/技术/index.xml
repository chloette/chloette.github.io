<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术 on Hello Friend</title>
    <link>/categories/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on Hello Friend</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 20 Jun 2015 08:35:16 +0000</lastBuildDate>
    
	<atom:link href="/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Android支持按键双击事件</title>
      <link>/posts/android-support-double-tap/</link>
      <pubDate>Sat, 20 Jun 2015 08:35:16 +0000</pubDate>
      
      <guid>/posts/android-support-double-tap/</guid>
      <description>最近做的东西比较杂，是得梳理一下了~
参考了这篇文章。
按键双击，这种组合键的做法类似volume down键 + power键 = 截屏
因为两个按键之间肯定会有时间差，而双击其实就是x键 + x键；
开翻~
Android上keyevent，在framework层是由window manager来负责转发，找到PhoneWindowManager，会发现这里对于keyevent的各种intercept简直就是hook的绝佳地点：
interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags)
interceptKeyBeforeQueueing(KeyEvent event, int policyFlags)
等。。。
找到interceptKeyBeforeDispatching对volume down + power的处理（或者直接参考mHomeDoubleTapTimeoutRunnable），参考即可（可以顺着mVolumeDownKeyTriggered去看在哪里触发，在哪里判定tolerance的）
基本流程就是： volume down先被点击的时候，记录下来时间； power点击的时候，判断是否在tolerance里面； 同理，power先被点击的时候，一样记录下来时间； 在volume down被点击的时候，判断是否在tolerance里面；
这样就确定了是否是截屏“操作”，如果是，就consume这个事件（不再向上转发，直接return掉）；同时通过mScreenshotRunnable去截屏。
同样，双击事件也一样（甚至更简单），前一次点击纪录下来时间，下次点击计算是否在tolerance中即可（就不贴代码了，因为太懒（烂）了。。。）
其实L的代码，在window manager这里已经实现了volume down + power、volume up + power、 double tap home；参考对应的来实现一个即可。
还有一点就是如何在屏幕没点亮的时候监听按键；
在interceptKeyBeforeQueueing中找到interactive，（还没试，应该是用这个来决定是否screen on）
就这个啦，即使这个为false的时候依然把keyevent传递出去就好了~ （或者简单点就参考power键~ ）
基本如上~
TADA~</description>
    </item>
    
    <item>
      <title>用Selinux遇到的限制</title>
      <link>/posts/selinux-limitation/</link>
      <pubDate>Sat, 20 Jun 2015 06:58:44 +0000</pubDate>
      
      <guid>/posts/selinux-limitation/</guid>
      <description>（一停手就是若干年啊。。。）
在做一个有趣的小功能，具体什么就不说了。中途遇到了一个问题，media进程直接写文件的时候无权限：
fopen后strerrno(errno)是：permission denied.
翻了翻，应该是sepolicy（selinux）的限制导致的。
找到篇文章大概介绍了selinux和sepolicy设置（android L开始是建议厂商强制使用的）
还有一篇更偏实用。
打开/external/sepolicy/mediaserver.te
（其实还有一个device/qcom/sepolicy/common/mediaserver.te，暂未确认是用哪个，还是做了一个交集）
但可以确认的是camera_data_file应该是可写的：
allow mediaserver camera_data_file:dir rw_dir_perms; allow mediaserver camera_data_file:file create_file_perms;
那具体camera_data_file是哪里那？继续翻：
在/external/sepolicy/file_contexts里面：
/data/misc/camera(/.*)? u:object_r:camera_data_file:s0
既然这样，那就直接往这个目录下面写吧~
改完测试，一切OK~</description>
    </item>
    
    <item>
      <title>关于Camera（成像）</title>
      <link>/posts/about-camera-sensor-1/</link>
      <pubDate>Sun, 03 May 2015 14:23:04 +0000</pubDate>
      
      <guid>/posts/about-camera-sensor-1/</guid>
      <description>其实早就想写，但这种题目会让模电考试作弊才堪堪及格的我压力山大。。。
注意：这里的camera，基本指目前绝大多数的电子成像设备。
本文从一个有基本理科知识的角度，来科普性质的讲讲图像传感器都干了些什么（才助力陈老师造福全人类的）。当然也一定会有遗漏缺失错误的地方（不吝指出~）
本文很多内容，是基于《CMOS图像传感器集成电路原理、设计和应用》（罗昕 编著），这本书不错，让我重新梳理所学，值得看一看~
#####小孔成像
在说到图像传感器前，先说说小孔成像；这是目前所有成像技术的光学基础 &amp;ndash; 光是直线传播的（在忽略引力作用的前提下）：
尽管我不喜欢baidu，但是这篇百科中，墨子如是说：
 “景。光之人，煦若射，下者之人也高；高者之人也下。足蔽下光，故成景于上；首蔽上光，故成景于下。在远近有端，与于光，故景库内也。”
 用通俗的话说，就是说照射在人身上的光线，（反射出去）就像射出去的箭；下面的光也会（反）射向上方，上部的光也会（反）射向下方，（通过小孔时），小孔下半部分挡住了下面的光，所以足部成像在上面；小孔上半部分挡住了上面的光，所以头部成像在下面。
墨子居然就这么轻描淡写的，阐述了：光是直线传播的。
######有个疑问是，那小孔变成大孔那？为何不能成像了？
因为。。。假设大孔无限大，这样反射光就全无遮拦无过滤的混在一起了，光线们都没羞没躁的混在一起，就是白色（总觉得哪里不太对啊嘿嘿嘿）了嘛。
基于此，人类有了真实记录自己的理论依据。
再之后，通过对感光材料的研究，人类发明了照片。
#####既然已经知道了成像的原理，那camera如何成像的？
分三步：
 把冰箱门打开 把大象推进去 把冰箱门关上  。。。好吧其实是这么几步：
 光，打到sensor（像素阵列每个像素的）光电二极管上，激发电荷  &amp;mdash;如果是CCD
 逐行逐列的读取 电荷信号经过电荷-电压转换电路转换成模拟电压信号 电压信号通过常规模拟电子电路实现放大  &amp;mdash;如果是CMOS
 激发后的电荷通过像素上的电路转换为电压并放大 逐行逐列的读取  &amp;mdash;结束如果
 通过模数转换将模拟电压信号转换为数字信号 通过差分传输将数据从sensor传输到isp ISP将sensor传出的数据（根据pattern不同，目前主流是bayer的GRGB结构）进行整帧组装 ISP开始对这一帧进行处理（如lens shading，color enhancement, crop等），最终输出YUV（或其他常规格式）的整帧数据。（这里先忽略3A） Jpeg encoder（目前主流均已hw化了）将整帧数据写入jpeg文件（因为上面忽略了3A，这里的exif也顺带忽略~） 恩，可以上传照片到朋友圈了  似乎有点复杂，简化下：
光 -&amp;gt; 1.光电二极管 -&amp;gt; 2.生成电荷 -&amp;gt; 3.转换到电压并放大信号 -&amp;gt; 4.阵列化逐行逐列输出 -&amp;gt; 5.电压信号模数转换到数字信号 -&amp;gt; 6.传输给ISP -&amp;gt; 7.ISP处理成YUV -&amp;gt; 8.</description>
    </item>
    
    <item>
      <title>Android Camera HAL3.0</title>
      <link>/posts/android-camera-hal3-0/</link>
      <pubDate>Sat, 11 Apr 2015 07:15:21 +0000</pubDate>
      
      <guid>/posts/android-camera-hal3-0/</guid>
      <description>官网文档在此
简单来说，3.0的设计初衷就是 &amp;ndash; 提供per-frame操作的灵活性。
更多细节在官网上写的很清楚了，这里就不再赘述。
罗列一些点，跨度比较大，想到哪说到哪。
######Camera 接口 首先接口本身的设计存在缺陷：
例如setPreviewSize和setPreviewFrameRate是无关的。（但其实这很有关系）
对于ISP这种pipeline来说，类比水管，最大出水量是恒定的；所以理论上，单帧size越大，那帧率（fps）也就越低。
所以size和fps是应该有明确的对应关系的。但这个接口把这个关系打破了。
那是否就无法获取这种对应关系了那？
并不是。Camera提供了CameraCharacteristics来获取更具体的信息，但是要麻烦一些；
可以参考cts测试中，getAvailableMinFrameDurationsForFormatChecked的做法；通过StreamConfigurationMap来算出fps和width/height的关系。
######CTS CTS的加强； 5.0以来，camera的CTS测试case从3x项增加到了3xx项。。。通过cts更加困难。 初衷是好的，会改善android目前不容乐观的rom兼容性。 但真相是，这套测试更像是一张考卷，上有政策下有对策的大有人在。
（不断补充ing）</description>
    </item>
    
    <item>
      <title>My ghost upgrade script</title>
      <link>/posts/my-ghost-upgrade-script/</link>
      <pubDate>Fri, 06 Mar 2015 05:09:09 +0000</pubDate>
      
      <guid>/posts/my-ghost-upgrade-script/</guid>
      <description>最后的最后，还是写了一个： 一行命令就升级ghost的脚本（包括：ghost升级、google font cdn优化、首页摘要显示优化、logo优化、首页图片显示优化、prism高亮code、disqus评论）。
ghostUpgrade
io page
####Environment before using:
 Ubuntu 14.04 (or similar) ghost0.5.x npm/nodejs/forever  ####How to use:
 clone to folder-of-code add executable permission to upgrade_ghost.sh and start_ghost.sh like this: chmod a+x folder-of-code/*.sh change folder-of-ghost in start_ghost.sh to actual ghost folder If you need comments (Disqus only), upgrade like this: folder-of-code/upgrade_ghost.sh folder-of-ghost folder-of-code Disqus_forum_shortname, otherwise: folder-of-code/upgrade_ghost.sh folder-of-ghost folder-of-code Waiting&amp;hellip;  LOL~ Enjoy your ghost~
####What&amp;rsquo;s upgrade_ghost.sh doing：</description>
    </item>
    
    <item>
      <title>Ghost代码高亮</title>
      <link>/posts/ghost-highlight-syntax/</link>
      <pubDate>Wed, 04 Mar 2015 03:15:57 +0000</pubDate>
      
      <guid>/posts/ghost-highlight-syntax/</guid>
      <description>Ghost本身的代码高亮是很粗糙的，如下：
//This is code sample int x = 0; int y = 1; x = y++; ...  但是代码至少应该像下面这样才好看啊！
//This is code sample int x = 0; int y = 1; x = y++; ...  翻了翻ghost的论坛，发现了prism，使用可以参考这里
下载css/js的时候可以选择自己需要的高亮语言等。
这样就又需要修改server上用来更新ghost的bash了：
#copy prism js/css to content and use it (to highlight codes) cp ~/prism/prism.js ./content/themes/casper/assets/js/ cp ~/prism/prism.css ./cotent/themes/casper/assets/css/ sed -i &#39;s~&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;{{asset &amp;quot;css/screen.css&amp;quot;}}&amp;quot; /&amp;gt;~&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;{{asset &amp;quot;css/screen.css&amp;quot;}}&amp;quot; /&amp;gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;{{asset &amp;quot;css/prism.</description>
    </item>
    
    <item>
      <title>Android library loading limitation</title>
      <link>/posts/android-library-loading-limitation/</link>
      <pubDate>Thu, 12 Feb 2015 04:27:27 +0000</pubDate>
      
      <guid>/posts/android-library-loading-limitation/</guid>
      <description>Android上想调用native算法库（so的形式），只能走JNI的路（用NDK来编译）；
加载so的时候一般是用System.loadLibrary或System.load；
使用前者，则so只能提前push到系统目录或app对应目录下（不然找不到）；
使用后者，一般情况下无路径的特别限制；这样便于控制app size（so可以单独下载到特定目录）；
但是自从某个os版本后（确实不知道哪个版本后），sdcard卡上的so，也有了加载的限制。
例如报错：Android load library error — failed to map segment
该问题其实算是设备相关，某些内置卡的设备就不存在该问题；也正如stackoverflow上的回答，是权限问题；
出现该问题的设备：
正常的设备：
可以明显看到权限差异。
把so目录改到context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).dataDir后，就OK了。
记录一下，小坑怡情。</description>
    </item>
    
    <item>
      <title>APK Expansion limitation</title>
      <link>/posts/apk-expansion-limitation/</link>
      <pubDate>Wed, 11 Feb 2015 07:17:39 +0000</pubDate>
      
      <guid>/posts/apk-expansion-limitation/</guid>
      <description>APK Expansion
公司的App打算shrink app size &amp;ndash;&amp;gt; 因为有用户抱怨说app太大了看起来就觉得浪费资源bulabulabula。。。
其中APK Expansion也被列为了备选方案；翻了文档和Sample源码后确认了APK Expansion的一些限制：
 超过50M的apk强制要求使用，不超过也可以使用； 可以使用任何格式作为expansion file，但只能有一个main，一个patch（即最多两个，各不超过2G） expansion的size算在app中；如160M的游戏，apk只有20M，但下载后app info看到的size依然是160M； expansion在一般情况下(on most devices)会随apk一起下载；在某些不能下载的设备上，可以手动下载；无法由app来选择，是否随apk一起下载； 需额外增加权限：com.android.vending.CHECK_LICENSE（google play） 和 android.permission.WAKE_LOCK（保证下载时cpu alive）  从app的角度来看，几乎没有好处。app size没有减少、下载的时候也是一起下载（没有lazy机制）、还需要额外权限。。
所以这条方案基本可以pass了。
另外的方案就是把可以shrink的资源，放在自己的服务器（或cdn）上，然后下载后再load；灵活性高很多，问题就是不确定服务器（或cdn）是否在犄角旮旯的地方都靠谱了。（分包apk的方案之前有提到）
记录一下。</description>
    </item>
    
    <item>
      <title>zsh &#43; oh-my-zsh &gt; default shell</title>
      <link>/posts/zsh-oh-my-zsh/</link>
      <pubDate>Tue, 10 Feb 2015 07:12:29 +0000</pubDate>
      
      <guid>/posts/zsh-oh-my-zsh/</guid>
      <description>尽管换上了MBP，terminal的使用还是不少的。。。
而且相比较ubuntu的terminal，osx默认的shell。。。配色太“单调”，提示也很弱。
所以找到了zsh + oh-my-zsh
安装配置文档都有。
可以自己make install zsh再手动配置oh-my-zsh；
或者直接curl -L http://install.ohmyz.sh | sh
plugin设置好自己常用的（例如adb、git、go、osx、python等等）；
然后选择一个喜欢的配色主题，就这么愉快的开工吧：</description>
    </item>
    
    <item>
      <title>Photo gallery from folder</title>
      <link>/posts/photo-gallery-from-folder/</link>
      <pubDate>Mon, 09 Feb 2015 07:26:01 +0000</pubDate>
      
      <guid>/posts/photo-gallery-from-folder/</guid>
      <description>当有大量图片需要快速分享出去的时候（例如出去玩，拍了大量照片，分享就变成了大麻烦；如果可以有一个简单的server（或其他机制）来快速分享，那就好多了）
目前搬砖的公司就遇到这个情况，年会有照片，但是因为共享机制的差异（mac访问windows共享），导致公司有不少同学无法拿到照片。
工作机之前搭过amp的环境，所以为了省时省力，就去搜了php gallery from folder
Google前两位分别是UberGallery和FolioGallery
都蛮不错。我选择了后者（因为后者天生支持multi-directory listing！）
搭建起来很容易：
 下载并解压缩放到web目录下 图片放到albums目录下 albums目录为www-data增加可写权限（因为需要在子目录下生成thumbnail） 浏览器打开foliogallery.php（点击对应目录生成thumbnail）  这就OK了！简单吧~ 效果如下：
点击会popup一个大图预览；
大图点击可以左右切换图片；
而且自带slideshow；
基本功能都满足了~
可能会遇到的问题就是图片显示不出来（例如我T_T）：
 Requirements：
A server running PHP 5+.
PHP GD library (for automatc thumbnail creation).
jQuery JavaScript library.
 安装一下：
sudo apt-get install php5-gd &amp;amp;&amp;amp; sudo service apache2 restart  Tada~~
BTW，这看起来可以做一个很有趣的小玩意儿啊~
快速上传，然后用类似Gallery的方式分享，然后大家都可以互相编辑，点赞，加评论等~
很有意思~</description>
    </item>
    
    <item>
      <title>Ghost修改screen.css的脚本</title>
      <link>/posts/script-to-modify-ghost-screen-css/</link>
      <pubDate>Wed, 21 Jan 2015 12:07:06 +0000</pubDate>
      
      <guid>/posts/script-to-modify-ghost-screen-css/</guid>
      <description>Ghost更新越来越频繁，每次都要手动更新css实在伤不起。。。
反正改动的地方也不多，干脆做成一键脚本好了，把之前upgrade的脚本再扩展一下：
首先更改#7，改动如下，增加了change logo position：
#change post page what to show... echo &#39;7. replace &amp;quot;excerpt&amp;quot; with &amp;quot;content&amp;quot; ---------------&#39; #excerpt -&amp;gt; content #read more -&amp;gt; &amp;gt;&amp;gt; sed -i &amp;quot;s#&amp;lt;p&amp;gt;{{excerpt words=\&amp;quot;26\&amp;quot;}} &amp;lt;a class=\&amp;quot;read-more\&amp;quot; href=\&amp;quot;{{url}}\&amp;quot;&amp;gt;&amp;amp;raquo;#&amp;lt;p&amp;gt;{{content words=\&amp;quot;32\&amp;quot;}} &amp;lt;a class=\&amp;quot;read-more\&amp;quot; href=\&amp;quot;{{url}}\&amp;quot;&amp;gt;\&amp;amp;raquo;\&amp;amp;raquo;#g&amp;quot; ./content/themes/casper/partials/loop.hbs #change logo position sed -i &#39;s~{{#if @blog.logo}}&amp;lt;a class=&amp;quot;blog-logo&amp;quot; href=&amp;quot;{{@blog.url}}&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;{{@blog.logo}}&amp;quot; alt=&amp;quot;Blog Logo&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;{{/if}}~~g&#39; ./content/themes/casper/index.hbs sed -i &#39;s~&amp;lt;h1 class=&amp;quot;page-title&amp;quot;&amp;gt;{{@blog.title}}&amp;lt;/h1&amp;gt;~{{#if @blog.logo}}&amp;lt;a class=&amp;quot;blog-logo&amp;quot; href=&amp;quot;{{@blog.url}}/about&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;{{@blog.logo}}&amp;quot; alt=&amp;quot;Blog Logo&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;{{/if}}&amp;lt;h1 class=&amp;quot;page-title&amp;quot;&amp;gt;{{@blog.title}}&amp;lt;/h1&amp;gt;~g&#39; ./content/themes/casper/index.hbs  再就是考虑到自己智商太低，难以驾驭sed的多行匹配，所以祭出Python；脚本中加上这句：
#call python to do multiple lines replacement python ~/ghost_css_adjustment.</description>
    </item>
    
    <item>
      <title>Android ImageFetcher</title>
      <link>/posts/android-imagefetcher/</link>
      <pubDate>Wed, 21 Jan 2015 06:15:21 +0000</pubDate>
      
      <guid>/posts/android-imagefetcher/</guid>
      <description>Google完善文档后，也提供了一大批优秀的源代码。
ImageFetcher就是其中之一，这货非常简洁的实现了用ImageView来异步加载网页图片，同时对图片进行二级缓存的功能。
稍微改改就可以轻松适配任何图片资源（例如本地，例如需特殊条件（如宽高，比例，透明度等）等）了。
主体代码构成： 外部调用如下：
 New：
ImageFetcher imageFetcher = new ImageFetcher(context, width, height);  就可以了。
当然这里一般都会改动；
例如为了区分cache目录，会把unique folder name作为参数传入进去）。
例如为了替换默认图，把图标传进去。
例如为了适配任何图片资源，增加自定义的ImageProvider，也在初始化的时候传进去。
 Load bitmap：   imageFetcher.loadImage(pathString, (ImageView) view.findViewById(R.id.thumbnail));   这样这个ImageView就会在图片通过异步下载好（并缓存）以后，自己加载显示出来了～
 Close cache：  imageFetcher.setPauseWork(false); imageFetcher.closeCache();  就是这么简单任性～
内部逻辑重点的几个：
 对Download下来的图片，使用DiskLruCache来本地缓存，使用LruCache作为内存缓存；
 使用AsyncTask（WeakReference）来异步download图片；结束后对ImageView（WeakReference）进行setImageDrawable（AsyncDrawable）；这里的AsyncDrawable内部有正在处理自身的AsyncTask的WeakReference，所以可以避免重复execute的情况；每次都会先cancel之前的。
 AsyncTask跑在Executor（线程池）中。
  主要原理就是这样，其中一些细节可以自己翻源码～～ 非常方便使用和扩展～ 基本已经成为搭项目时必备库之一。
但是这里有一点，需要注意！
谨慎使用ImageFetcher.setPauseWork
官方Sample给出了两个用法，看起来前后有一点矛盾：
一个是在Grid滑动的时候：
public void onScrollStateChanged(AbsListView absListView, int scrollState) { // Pause fetcher to ensure smoother scrolling when flinging if (scrollState == AbsListView.</description>
    </item>
    
    <item>
      <title>EC2 /dev/xvda1 should be checked for errors</title>
      <link>/posts/ec2-devxvda1-should-be-checked-for-errors/</link>
      <pubDate>Tue, 20 Jan 2015 06:54:26 +0000</pubDate>
      
      <guid>/posts/ec2-devxvda1-should-be-checked-for-errors/</guid>
      <description>今天ssh登到EC2，发现报这个问题：
/dev/xvda1 should be checked for errors  短板突显，翻了翻google，比较靠谱的是这个：
Running fsck on EC2
已试，靠谱～
记录一下～</description>
    </item>
    
    <item>
      <title>Proguard混淆</title>
      <link>/posts/proguard-obfuscation/</link>
      <pubDate>Sat, 17 Jan 2015 08:01:38 +0000</pubDate>
      
      <guid>/posts/proguard-obfuscation/</guid>
      <description>这里仅仅说Android的混淆，其他平台基本相同。
不同的IDE有不同的配置方法。
Android Studio的配置略有差异，可以参考前文
混淆的大致原理就是rename class（所以混淆的过程比较慢），混淆的初衷，并不是为了不让人看源码，毕竟java的虚拟机机制就决定了，源码肯定是可以反编译出来的；其主要目的是让反编译后的代码“难以”看懂。
例如打开一个混淆后输出的mapping文件，可以看到：
（某代码片段，请无视。）
这样一来，反编译后的代码里面，基本就是a.b.c(d.e)这种代码（也许原来只是Util.isNetworkAvailable(context)），大大增加了阅读难度；也就达到了防止反编译的目的。
但经常会误伤，因为是rename，所以对name敏感（依赖name）的方法或者库就会无法正常工作。例如反射，例如JNI的接口class（依赖class name来找context object），例如GSON这些常用工具库。
解决办法就是修改proguard的配置文件，将这些敏感class置为例外。
常用方法如下：
 排除指定类A
-keepclassmembers class com.xxx.xxx.A { *; }   将类A的子类全部排除 language-bash -keepclassmembers class * extends com.xxx.xxx.A { *; }   将包P内的class全部排除
-keep public class com.xxx.P.* { *; }   将包P内的class及subclass全部排除 language-bash -keep public class com.xxx.P.** { *; }     注意*和**的差别；
注意最后的{ *; }，用法很多，可以指定仅排除public/protected，如：
{ public protected *;}  当然还可以直接更直接一些：
{ &amp;lt;fields&amp;gt;; &amp;lt;methods&amp;gt;; }  如果是使用Gson的话，还可以直接如下使用方式来避免混淆问题：</description>
    </item>
    
    <item>
      <title>Jenkins&#43;Github&#43;Gradle&#43;Android</title>
      <link>/posts/jenkins-github-gradle-android/</link>
      <pubDate>Thu, 15 Jan 2015 13:17:06 +0000</pubDate>
      
      <guid>/posts/jenkins-github-gradle-android/</guid>
      <description>也许题目换成《配置以Github作为源码仓库并用Gradle编译Android的Jenkins时遇到的坑》更恰当~ LOL~
网上教学贴很多，不一一列举了。也可以参考前一篇（BTW，我想说Subversion Release Plugin比自带的Subversion Plugin好用多了）。本文主要补充配置Github和Gradle容易遇到的问题。
重要的plugin：
 Git plugin
 Gradle plugin
  至于Github plugin之类的插件，自己看着办吧。
这里有几个容易出问题的地方
 如何用Jenkins从Github获取代码：  建议使用Deploy keys
怎么用那？最好用.ssh/config，可以参考这里。
需要注意的是，在创建ssh key的时候，需要
sudo -u jenkins ssh-keygen -t rsa -f .../jenkins/.ssh/id_rsa_project  加-u来指定以jenkins身份创建key，加-f就是为了方便多个ssh key（例如多repository）的时候好管理。
同时，创建出来的ssh key不要设置密码，因为jenkins对ssh key密码的支持不是特别好，会报public key permission错误（非访问权限问题）。BTW，虽然github提到deploy keys缺点时有说，这货一般为了方便不加密码；但通过command方式，用带密码的ssh key去访问github是没问题的。
当然Github还提供了一套更华丽的方式，叫Machine user，简单说就是单独申请一个账户（类似一个代理），把这个账户加到不同的repository里面作为只读的collaborator，再直接在这个账户里面加ssh key（而不用每个repository一个deploy key了），这样通过这一个machine user（代理）就可以访问多个repository了。
最后，这里去clone/pull代码的时候，有时候出报timeout的错误，解决方法有两种，一种是在该目录下，手动git clone &amp;ndash;bare一个repository出来；再一种就是增加timeout时间：源码管理 -&amp;gt; Git -&amp;gt; Additional Behaviours -&amp;gt; Advanced clone behaviours
 如何用Jenkins来run Gradle：  需要手动匹配gradle版本。在系统设置里面新增Gradle安装即可，不然在Invoke Gradle script的时候，除了default就没得选了。
JAVA_HOME和ANDROID_HOME这两个环境变量需要提前设置好（可以在/etc/profile里面export，然后source /etc/profile即可）；修改环境变量后需要重启jenkins；同时注意对应的目录，jenkins是否有访问权限；</description>
    </item>
    
    <item>
      <title>Android SparseArray中indexOfValue返回-1</title>
      <link>/posts/android-sparsearray-indexofvalue-return-negative-1/</link>
      <pubDate>Tue, 13 Jan 2015 12:55:43 +0000</pubDate>
      
      <guid>/posts/android-sparsearray-indexofvalue-return-negative-1/</guid>
      <description>继续Android。
SparseArray&amp;lt;T&amp;gt;是蛮好用的基本类型，一般用来替换掉HashMap&amp;lt;Integer, T&amp;gt;。
有时候偷懒，也会用它来替换Object[]，也就是基本数组。
因为这货有indexOfValue（这样就不用去遍历找索引啦），遍历也比HashMap方便的多。可以满足对基本数组的需要（但性能不高，使用需谨慎，文档有详细解释为什么）。
但是，这玩意儿有个坑，也就在indexOfValue里面。
当用它来存储String时，可能会出现明明Value已经put进去了，但是indexOfValue就是返回-1的情况。
一开始还以为可能是线程安全相关的问题，还打算加锁来着。结果。。。
原因在于：
 Note also that unlike most collections&amp;rsquo; indexOf methods, this method compares values using == rather than equals.
 源码如下：
public int indexOfValue(E value) { if (mGarbage) { gc(); } for (int i = 0; i &amp;lt; mSize; i++) if (mValues[i] == value) return i; return -1; }  T_T
Java中，字符串比较用==和equals的区别就不用解释了吧。。。
你说Android你加个方便好用的数据结构你用个equals能咋样。。。又中枪了。。。</description>
    </item>
    
    <item>
      <title>Android RelativeLayout中wrap_content和alignParentBottom的冲突</title>
      <link>/posts/android-conflict-of-relativelayout-between-wrapcontent-and-alignparentbottom/</link>
      <pubDate>Mon, 12 Jan 2015 08:25:33 +0000</pubDate>
      
      <guid>/posts/android-conflict-of-relativelayout-between-wrapcontent-and-alignparentbottom/</guid>
      <description>继续随便记录一下，之前也说过，Android类似的坑不少。
下面又是一例：
RelativeLayout中，为了方便布局，子view经常会用到alignParentBottom/Top/Left/Right等，如：
android:layout_alignParentBottom=&amp;quot;true&amp;quot;  但这时候需要注意的是，如果parent是wrap_content的话，alignParentRight就意味着要求parent的layout_width=&amp;quot;match_parent&amp;quot;； alignParentBottom就意味着要求parent的layout_height=&amp;quot;match_parent&amp;quot;
这会带来什么问题那？两个问题：
 显示错误。在布局嵌套的环境下，例如布局A包含B和C，在A里面，B above C：（伪布局代码）  RelativeLayout width=match_parent height=match_parent id=&amp;quot;A&amp;quot; XXLayout width=match_parent height=wrap_content above=&amp;quot;C&amp;quot; id=&amp;quot;B&amp;quot; RelativeLayout width=match_parent height=wrap_content id=&amp;quot;C&amp;quot; XXView width=match_parent height=wrap_content android:layout_alignParentBottom=&amp;quot;true&amp;quot; src=xxx  本意是希望在布局A里面，B可以在C上面显示，C里面显示xxx；
但是结果是：C会撑满A，然后导致B不可见。
改法很简单，去掉 language-bash android:layout_alignParentBottom=&amp;quot;true&amp;quot; 即可。
实际原因我没有去翻源码，不确定；但是猜测和Android的绘制/计算布局的方向有关，Android默认是从屏幕左上角向右下角绘制（在写自定义view，重载onDraw，或者坐标计算的时候需要依赖这种“特性”），所以在这种情况下，alignBottom或alignRight后，“画布”就自然而然被顶到下边和右边去了。
 性能。对，就是性能；撑满屏幕意味着这个view（例如上面的C）的刷新，不只是局部刷新，而是整屏刷新（即使XXView可能只是一个bottom bar这种非全屏的view），所以不管是耗电量还是性能，都会受到一定的影响。  综上，在设计layout的时候，需要注意方向带来的影响，同时注意不同属性之间可能导致的“冲突”。
记录一下。</description>
    </item>
    
    <item>
      <title>Android LinearLayout动态增加item时Weight的设置</title>
      <link>/posts/android-linear-layout-weight-setting-when-adding-child-dynamically/</link>
      <pubDate>Fri, 09 Jan 2015 04:50:13 +0000</pubDate>
      
      <guid>/posts/android-linear-layout-weight-setting-when-adding-child-dynamically/</guid>
      <description>Andorid上，LinearLayout动态增加child item时，一般如下：
addView(child)  即可。
child item可以从xml中直接inflate出来。
这里有个问题是，动态增加的话，child item中的weight，在add到LinearLayout后无效（用LinearLayout，很多时候就是冲着weight去的，因为可以很容易做到对齐和分割）。
唯一的办法是在addView的时候用新的LayoutParams来指定weight：
addView(child, new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1));  最好设置一下weightSum：
setWeightSum(childCount);  Android的layout配置中，类似的坑数不尽。。。再加上不同OS版本的不同表现，简直了T_T。。
记录一下。</description>
    </item>
    
    <item>
      <title>Ghost开机启动</title>
      <link>/posts/ghost-boot-up/</link>
      <pubDate>Thu, 08 Jan 2015 02:30:07 +0000</pubDate>
      
      <guid>/posts/ghost-boot-up/</guid>
      <description>Ghost本身是基于node.js的，这意味着 &amp;ndash; 常驻后台需要用到其他方式，例如&amp;amp;或者forever（官网建议）
但这样也需要使用类似sudo start_ghost.sh这种方式来启动，想开机启动的话还是需要使用update-rc.d或者cron
前者官网提供了一个说明，相当于自己写一个service
后者比较强大，用在这里有点大材小用。
简单点的做法就直接参考stackoverflow
sudo mv /filename /etc/init.d/ sudo chmod +x /etc/init.d/filename sudo update-rc.d filename defaults   Script should now start on boot. Note that this method also works with both hard links and symbolic links (ln).
Edit
At this point in the boot process PATH isn&amp;rsquo;t set yet, so it is critical that absolute paths are used throughout. BUT, as pointed out in the comments by Steve HHH, explicitly declaring the full file path (/etc/init.</description>
    </item>
    
    <item>
      <title>Ghost首页图片限制宽高</title>
      <link>/posts/ghost-limit-image-width/</link>
      <pubDate>Tue, 06 Jan 2015 03:26:26 +0000</pubDate>
      
      <guid>/posts/ghost-limit-image-width/</guid>
      <description>还是默认Theme。
如何显示图片可以参考[Ghost在首页显示图片而非摘要]
但是这样修改有一个地方漏掉了。就是图片的宽高，普通图片还好，但到了大图，就坑爹了。在首页显示比较大的图片，会直接撑破侧边。。。
本来以为Ghost应该支持类似![](xxx.jpg =500x)（以500 x auto的宽高来显示xxx.jpg）这种语法，结果不支持。。。
搜一搜，可以发现Ghost讨论组对于支持image的复杂操作（例如resize，旋转等）的呼声还是很高的，而且专门列了一贴来讨论，并且给出了若干可能的解决方案（都有各自的优缺点）。
这里先不考虑多size来适配的case，这交给Ghost的大神们吧～
我只是希望首页显示图片后，图片宽高可控。
解决方法有两种：
一种是直接把./partials/loop.hbs里，post-excerpt项的class直接修改为post-content～
&amp;lt;section class=&amp;quot;post-content&amp;quot;&amp;gt; ... &amp;lt;/section&amp;gt;  这样的好处是方便，坏处（我觉得蛮好的）就是首页的文字风格和page页完全一样（例如字体大小，行间距等），没区别了。
还有一种就是增加post-excerpt img的css，直接copy post-content img然后改一下名字即可：
/* Keep images centred and within the bounds of the post-width */ .post-excerpt img { display: block; max-width: 100%; height: auto; margin: 0 auto; padding: 0.6em 0; }  好处是首页风格保持和之前一致，坏处嘛，稍微麻烦一点点。哈哈～
暂时先这么处理吧（BTW，我选择的是后者）。
按照Ghost的说法，Image Process已经放入Road map，坐等版本更新吧～</description>
    </item>
    
    <item>
      <title>关于字符编码</title>
      <link>/posts/about-charset/</link>
      <pubDate>Wed, 31 Dec 2014 13:10:19 +0000</pubDate>
      
      <guid>/posts/about-charset/</guid>
      <description>以下内容纯个人理解，如有遗漏/错误等我反应过来再补充吧～
（感觉还是用类似Q&amp;amp;A的方式来写写比较好）
######什么是字符？
在计算机里面，无意义的二进制0和1（如果不知道的话，继续看下去也没什么意义了。。。），按照特定的长度可以表示一个数值（例如二进制的1000表示十进制的8）；对于不同的数值，如果有一个table来映射（有没有密码本的赶脚），那不同的数值就可以表示特定的含义 &amp;mdash; 字符。
例如，二进制里面的01000001：
 十进制（也理解成表的话，只是“映射”方式更简单）就是65 在ASCII表里，对应的是英文大写字母A  你看，同一个数值，通过不同的table，就有了不同的含义（小马过河的即视感。。。）。
######什么是字符编码？
很显然，ASCII这个表能表示的含义太少了（只有128个，而且其中还有33个不能显示的字符），尽管用来表示英文（A-Z + a-z + 一些常用符号）是足够了，但你让其他语言怎么看？
所以不同的国家，就有了各自的一张Table；这些Tables，就统称为ANSI编码。所以一般说ANSI编码，不是单指简体中文的GB2312或者日文的JIS，而是指这个合集，指这种“每个国家都不同但又是各自国家标准的编码表”。
######一个国家一张表？
一个国家一张表，听起来不错，但有个问题在于 &amp;mdash;- 这意味着，同一个数值，在不同国家表示的含义就不同了啊啊啊！
例如十六进制的0xD2BB这样两个字节：
 在GB2312中表示大写数字一 在JIS中表示ﾒｻ （不好意思我不知道这是啥意思。。。）  所以这就意味着，同一份文档，在不同国家，可能会出现显示内容完全不同的情况（一般情况下是乱码。。）
尤其是在大互联网浪潮下，这意味着，在本国打开一切OK的网页，在国外打开就是一团浆糊了：
（哈哈，其实本站不是ANSI编码，这里强制使用ANSI的JIS以后～ 就呵呵了～ ）
######乱码怎么办？
怎么办？两种办法：
 一种是找一个标准，大家统一使用，也就是目前渐成主流的Unicode编码； 再一种就是自动转换编码，例如你在大天朝，一般是用GB2312（简体中文）编码，那么如果想看一篇使用JIS编码的文章/网页，就需要你使用的阅读器/浏览器做两件事情：
 自动编码识别 &amp;ndash; 让阅读器/浏览器知道这篇文章/网页是JIS编码的 编码转换 &amp;ndash; 将JIS编码转换成GB2312编码（当然也可以在阅读器/浏览器内部，直接用JIS编码来显示）   ######什么是Unicode？
更具体的请Wiki。
简单来说，就是把不同的语言，按照特定的顺序，不重复的排列下去。组成一个巨大的“字典”（这也意味着这个字典的页数要够大）。
重点就是不重复
具体的可以看这里[Wiki]
有一点需要注意的是，Unicode是统称。
UTF-8/UTF-16/UTF-32等等，都是Unicode。
UTF-8就是为了存储和传输方便，缩小版的UTF-16。
显然的是，它们可以相互转换（不是查表，而是用公式）。
######为什么需要自动编码识别？
因为，很多情况下，目标文档的编码是未知的。
举个例子，这就好像古时候密码破译的场景，同一个密码，用不同的密码本对照破译，有可能会得到完全相反的含义。所以如何正确识别编码，就变得特别重要。
######那文档没有特定“编码识别符”么？
对，没有统一标准（即使是Unicode）。或者说没有“强制”执行的标准，来约定必须在文档某个位置标注当前文档编码类型的。
这也就意味着 &amp;ndash; 自动编码识别必不可少。
######如何自动编码识别？
很多算法，一句话就是“模式识别”。
举个例子，在中文里，一般会有一些出现频率较高的词，如“的、我”等等；不同的语言，常用词也显然是不一样的（当然可能存在特例，中文的“的”和日文的“的”都是高频词且十六进制数值一样（仅举例，显然不一样嘛），但就目前的统计数据而言，大部分高频词都一样的可能性几乎为0），所以算法基本如下：
 读取文档的一段内容（例如前4096字节），当然也可以全部读取 统计这段内容中对不同编码的高频词的命中率 命中率最高者即为“猜”到的编码  就是这么简单。</description>
    </item>
    
    <item>
      <title>谈谈12306的数据泄露</title>
      <link>/posts/about-data-leak-from-12306/</link>
      <pubDate>Thu, 25 Dec 2014 09:51:13 +0000</pubDate>
      
      <guid>/posts/about-data-leak-from-12306/</guid>
      <description>好奇的不仅仅是数据“如何”泄露，更好奇的是哪位同学居然敢老虎嘴里拔牙，敢情也是不想在大天朝混了。
看报道说是被撞库了（个人意见：12306今年的表现确实可圈可点）。那往前推，最可能的还是CSDN那次明文密码（大500W）泄露事件（后面有一次更大规模的17173/uuu9的泄露，也是受CSDN那波的影响）。
那就拿这13W的数据（纯研究，不提供下载链接 &amp;ndash; Google，你懂的）分析下看看吧。
祭出杀器Notepad++，打开居然是乱码。。。改编码到GB2312，恢复正常。
考虑到CSDN上男女比例应该严重失调，那就验证看看～
先统计一下女生（*身份证倒数第二位是偶数*）的数量。
打开正则表达式的WIKI（对，我就是记不住），当然也可以用RegExr～
\d{16}[02468](?=\d{1}|[xX])  然后Notepad++只hit到9860个结果。。。131653行的数据。
这男女比例（约12.4：1）。很符合CSDN的特征啊。
没错，CSDN，社工事业先驱者。
接下来的事情就比较有趣了，例如翻翻找找本地的妹纸啊，然后以*“同学你账号泄露了”*为名去勾搭吧～
随手查一下，*被泄露的成都本地90后妹纸*（正则：
510\d{3}199\d{7}[02468](?=\d{1}|[xX]) ```）有51个（就不截图了，你懂的～） 哈哈哈～ --- 【2014/12/26更新】 [12306网站泄密事件进展：2名犯罪嫌疑人已被抓](http://tech.sina.com.cn/i/2014-12-26/doc-icczmvun4410202.shtml) 呵呵，咱们开头说啥来着。 --- 【2015/1/7更新】 nodepad++确实神器，可惜ubuntu上用起来太麻烦。 直接上grep好啦，命令稍微改改（`\d`这种无法识别，用[0-9]代替） 例如搜索90后妹纸： ```language-bash grep -cE &#39;[0-9]{6}199[0-9]{7}[02468]([0-9]{1}|[xX])&#39; 12306.txt  结果只有1927个，但是notepad++上报出来是1928个。
很奇怪，还特意祭出Beyond Compare来比较结果，发现原来notepad++重复统计了某一行（那一行的同学，用身份证做账号。。。）
问题解决～</description>
    </item>
    
    <item>
      <title>Android docs (OpenGLES)</title>
      <link>/posts/android-docs-opengles/</link>
      <pubDate>Thu, 25 Dec 2014 08:39:37 +0000</pubDate>
      
      <guid>/posts/android-docs-opengles/</guid>
      <description>最近在看OpenGLES，一直没机会系统的学习，算是补补以前的遗漏；结果发现了Android对应的官方文档。
也不知道什么时候慢慢补全完善的Android文档，终于可以看得入眼，并且有一些确实不错的内容了。
Training不那么鸡肋了。
Guide也比以前好多了。
推荐一下Android关于OpenGLES的Training和Guide。
尤其是这一段开头：
 Being able to define shapes to be drawn in the context of an OpenGL ES view is the first step in creating your high-end graphics masterpiece. Drawing with OpenGL ES can be a little tricky without knowing a few basic things about how OpenGL ES expects you to define graphic objects.
 对，我相信初碰FFmpeg或者类似复杂框架时候，也必然会遇到这些“Tricky”但须遵循的逻辑和规则；深究下去后，自然会明白这么设计的初衷；OpenGLES也不例外。
而熟悉这些框架的过程就像驯服野兽：先适应它（强迫接受这概念），然后彼此获得信任（哦这样的代码(Sample)确实可以如它所说工作；按照这样的修改后它的表现也确实更好了），最后才能驾驭它（原来这样设计是基于底层这样那样的限制啊）
尝试去了解那些当初铺垫整个虚拟世界基石的先驱设计者们，他们面对这样那样的限制和难题，如何想出并实现各种精妙的方案；这会让每次的深入探索都像在翻一段无人知晓的历史，那种对无尽知识的感慨和对自身所学的匮乏之间的冲突会让人欲罢不能。
换个角度看，这欠的，也是醉了。
话说回来，Android也越来越像样子了~ 哈哈哈～</description>
    </item>
    
    <item>
      <title>关于FFmpeg（进阶）</title>
      <link>/posts/about-ffmpeg-advance/</link>
      <pubDate>Wed, 24 Dec 2014 09:11:09 +0000</pubDate>
      
      <guid>/posts/about-ffmpeg-advance/</guid>
      <description>基本篇在此。
目前仅使用到了ffmpeg的读写文件/编解码功能，并未使用其去直接渲染。
这里说是进阶，其实也只能算浮于表面。因此主要记录使用ffmpeg以来遇到的坑，版本差异，android版本编译等。So，这里就不继续采用Q&amp;amp;A的方式了。
（本文并非通过ffmpeg.exe\bin传递command来进行处理，而是直接调用ffmpeg相关libraries中的api）
####FFmpeg libraries FFmpeg有以下库：（2014/12/24 ffmpeg 2.5.2），主要功能列在About中有基本介绍，这里不再赘述。
 libavutil 54. 15.100 libavcodec 56. 13.100 libavformat 56. 15.102 libavdevice 56. 3.100 &amp;mdash; 未使用 libavfilter 5. 2.103 &amp;mdash; 未使用 libavresample 2. 1. 0 &amp;mdash; 未使用 libswscale 3. 1.101 libswresample 1. 1.100 libpostproc 53. 3.100 &amp;mdash; 未使用   ####FFmpeg基本 首先，官方文档为第一参考文档；其次就是源码（这里把*源码*放到这么靠前的原因下文会提到）。
FFmpeg的官方文档算是比较全的。 一些常见case的testbed都可以找得到；例如2.5版本，编解码的sample
同时官方的例子并非浅显易懂，但是因为层次简单，所以调用逻辑很清楚；参考着这些文档/Sample就可以按需设计一个简化版Adapter了。
####FFmpeg基本调用逻辑 还记得Decode/Encode和Muxer/Demuxer吧，如果还记得那就很好理解了。下面截选了部分代码（不要在意细节），有一些重要关键但非流程相关的步骤这里先省略（例如FIFO等），下文再提。
#####Encoding（Based on 2.x） - Register all codec //应该是plugin的机制
av_register_all(); avcodec_register_all();   Find encoder -&amp;gt; create stream -&amp;gt; open encoder  /* find the audio encoder */ p_audio_codec = avcodec_find_encoder(m_p_fmt_ctx-&amp;gt;oformat-&amp;gt;audio_codec); if (!</description>
    </item>
    
    <item>
      <title>DexIndexOverflow</title>
      <link>/posts/dexindexoverflow/</link>
      <pubDate>Tue, 23 Dec 2014 09:24:48 +0000</pubDate>
      
      <guid>/posts/dexindexoverflow/</guid>
      <description>Android工程，在工程代码较多（或复杂），依赖工程较多时，容易出现这个编译报错。
简单说就是Dex不支持非jumbo模式下，函数数量超过65535（请联想Youtube/鸟叔/点播次数）
一般修改方式如下：
Eclipse：
在project.properties（主工程）中增加
dex.force.jumbo=true  Android Studio：
在build.gradle（主工程）中增加
android { dexOptions { jumboMode true } }  </description>
    </item>
    
    <item>
      <title>Chrome cannot open profile correctly</title>
      <link>/posts/chrome-cannot-open-profile-correctly/</link>
      <pubDate>Fri, 19 Dec 2014 14:57:26 +0000</pubDate>
      
      <guid>/posts/chrome-cannot-open-profile-correctly/</guid>
      <description>Ubuntu版本的Chrome，很容易出现Profile cannot be opened correctly的错误。
结果就是无法正常使用账户同步功能（不能多设备同步我还用你干嘛！？！）
翻了翻资料，看了看log，发现这种时候新启动的chrome尝试去打开一个已经lock住的数据库（这不科学），然后就报错了。
继续翻，貌似每次第一次启动的chrome没有正常关闭，依然占用数据库（单例真的好么）。结果就是后面再启动的chrome尝试open，然后失败。
官方解决方法目前未找到。。。土方法就是 language-bash ps -A | grep &#39;chrome&#39;  然后kill吧。
Chrome现在也略不靠谱啊。T_T</description>
    </item>
    
    <item>
      <title>Onedrive Online无法访问</title>
      <link>/posts/onedrive-service-unreachable/</link>
      <pubDate>Fri, 19 Dec 2014 06:56:39 +0000</pubDate>
      
      <guid>/posts/onedrive-service-unreachable/</guid>
      <description>这几天偶尔出现这个“OneDrive unreachable”，麻烦的是，导致我甚至不能正常使用onenote（放在onedrive上的）了。
更奇怪的是，Chrome打不开（在线版本），但是Firefox正常工作。
想想MS和google不至于这么小心眼儿互掐。所以搜了一下，结果发现了这篇【微软OneDrive疑被屏蔽】
试着换了下google的开放DNS（实在太好记了，8.8.8.8,8.8.4.4）
结果就好了。Firefox正常的原因可能是有DNS缓存或者用自己的DNS。
大天朝不易啊，雾霾就算了，DNS污染也很严重。T_T</description>
    </item>
    
    <item>
      <title>Ubuntu14.10启动黑屏</title>
      <link>/posts/ubuntu-14-10-boot-black-screen/</link>
      <pubDate>Thu, 18 Dec 2014 07:35:40 +0000</pubDate>
      
      <guid>/posts/ubuntu-14-10-boot-black-screen/</guid>
      <description>现在在慢慢习惯Ubuntu做主系统，所以把小黑直接“刷”上了14.10，结果遇到了重启会黑屏的诡异问题（每次都要手动强制关机再启动）。T_T，不折腾会死啊。。
网上搜了一下，也没有具体的解决方案。但隐约都指向了显卡驱动。
那就试试看吧。
先
ubuntu-drivers devices  推荐使用的是nVidia的331驱动。
打开Additional Driver，显卡（古老的NV3100）默认选择的不是331。
那就果断换之～
之后重启（除了cryptsetup界面有点丑），一切正常～
～Tada～</description>
    </item>
    
    <item>
      <title>等不到OTA的Nexus5</title>
      <link>/posts/nexus5-manually-ota-to-lollipop/</link>
      <pubDate>Mon, 08 Dec 2014 12:59:04 +0000</pubDate>
      
      <guid>/posts/nexus5-manually-ota-to-lollipop/</guid>
      <description>美版刷了电信的Nexus5，11月13号就陆续概率发布的OTA，到现在都没收到，也是醉了。。。
手贱决定线刷OTA（sideload）。参考机锋教程
其中有一个步骤可能会卡住，就是准备adb sideload的时候，报：
insufficient permissions for device  解决方法就是用sudo，找到adb的路径（adk的platform-tools下面）
sudo ./adb kill-server sudo ./adb devices （这里会重启adb并列出对应的设备） sudo ./adb sideload &#39;xxx.zip&#39;  然后就静静的等待吧。。。
我还在等待 T_T
杯具了。。连续杯具3天。原以为一步搞定的。。。
电信的苦逼用户真是无可奈何。上了5.0，恢复EFS无效，最后迫不得已全清，然后从4.4.4开始刷。折腾快3天，系统从4.4.4刷到4.4.2又刷回5.0。。。
最后看到电信3G冒出来的时候真是泪流满面啊。。。
重新整理一下破解思路，如下：
 数据全清，重刷底包到4.4.4（数据自行备份，使用google身份验证器（基于OTP）的一定要备份，据我所知不止一个站点，支持了OTP但是在无原始OTP的情况下，不能重置）
 刷回4.4.4，启动系统后打开开发者模式。重启bootloader。
 刷TWRP的recovery，建议刷2.8.1的版本（这个版本在recovery模式下支持MTP，方便copy EFS的备份），重启会提示是否root，确认。
 重启系统后按照TWRP的提示，开始root。
 root后安装最新版的Nexus Field Test（需要最新版3.3；因为2.x的版本不支持4.4.3以上系统），DDD001（看过教程都懂的。）
这里注意，新版本的NFT，如果要获取SPC的话，需要通过右上角-&amp;gt;Setting(View)-&amp;gt;LTE-&amp;gt;Edit来获取。
 重启recovery，恢复EFS（同时恢复data更容易成功）或者重新破解，来恢复电信通话/短信/3G功能。 注意事项：
 破解时，ruim only总是被重置的话，建议用cdma workshop 来写。 破解时，cdma hdr总是被重置的话，建议插卡破解 破解时，每次重启建议通过锁屏键关机再重启，而不是用命令。目测关机时，基带也有一个关闭的过程，可能会记录一些状态来方便快速重启，如果直接命令关机可能导致重启后reset。 DFS可以使用新版本。   &amp;ndash;&amp;gt;到这里，4.4.4的电信就算破解完毕了。如果已经到了5.0，电信掉了还不死心的，请从这里开始看
 重启bootloader，直接线刷5.0（切记：数据备份，EFS备份），要保留数据的出门左转，我的数据已经清掉了所以也没办法试了。
注意：线刷有一些不同的版本，都是为了保留数据，有的教程是用修改flash版本的img来sideload的，有的教程说去掉-w的方法来update img，有的教程是只手动flash了boot/system/cache img；
我用的是版本是后者，但是接着就恢复出厂设置了。（所以和完整刷5.0底包没区别）【目测有些运气不错的同学，保留了数据又吃上了棒棒糖，给力～】
 恢复出厂设置后重启，并（想保留数据的，从这里开始看）重新root（即通过recovery刷supersu的2.37 zip包）
 重新安装NFT3.3版本，重新设置LTE，到DDD001（注意手动选择移动网络到3G，不然第一个选项可能无法disable）
 重点来了：关机-&amp;gt;拔卡-&amp;gt;恢复EFS-&amp;gt;开机-&amp;gt;插卡。如果3G信号+感叹号出来了，就意味着搞定了（我是一次搞定，回想之前刷失败的原因，应该就是忘记去设置DDD001）。 注意事项：</description>
    </item>
    
    <item>
      <title>Android studio 1.0 RC (更新)</title>
      <link>/posts/android-studio-1-0-rc/</link>
      <pubDate>Fri, 21 Nov 2014 07:00:33 +0000</pubDate>
      
      <guid>/posts/android-studio-1-0-rc/</guid>
      <description>终于等到Release了。。。
算是canary尝鲜版吧。
不易啊，跟进！
补充一个严重issue：[2014/11/24]
使用1.0RC版本，Close工程的话，再次进入会自动下载ADK而不去检查已经存在的ADK。。。
解决方法：
关闭Android Studio后删除该目录：
 系统盘/User/你自己啊/.AndroidStudio
 然后重新启动Android Studio并重新导入以下目录的配置文件：
 系统盘/User/你自己啊/.AndroidStudioBeta
 一切正常了。。。（还有一个大招是启动之前拔网线，然后就可以Skip了。。。）
路漫漫其修远兮啊。。。
T_T
继续补充。出去度假回来，结果都已经RC4.0了。。。你这版本号升级规则改的有点高调吧亲。
放羊两天（刷5.0。。。）居然已经1.0.0咯。。。这版本号真是随意啊～
打开ADK页面
发现Android studio居然转正（Official）了！而ADT bundle连下载链接都没了（动作真快）。。。
看来跟上的步伐不算慢，哈哈哈～</description>
    </item>
    
    <item>
      <title>Android java.lang.ClassNotFoundException</title>
      <link>/posts/android-java-lang-classnotfoundexception/</link>
      <pubDate>Wed, 19 Nov 2014 09:07:32 +0000</pubDate>
      
      <guid>/posts/android-java-lang-classnotfoundexception/</guid>
      <description>ClassNotFound原因较多，这里列一个特殊case：
抽象类A，因项目关系，code clean后，已无抽象方法（但依然带着abstract关键字）
没深究过java语法，不过没有抽象方法却声明为抽象类，至少该有个警告把？而这里Eclipse（ADT）/Android studio均无任何提示，所以怀疑是JDK的bug）。
Main activity继承自A。然后启动Main activity即报ClassNotFound。
log里面会有奇怪的：
11-19 16:51:21.301 W/dalvikvm(31571): Unable to resolve superclass of LxxxA; (207) 11-19 16:51:21.301 W/dalvikvm(31571): Link of class &#39;LxxxA;&#39; failed 11-19 16:51:21.301 W/dalvikvm(31571): Unable to resolve superclass of LxxxMain (1447) 11-19 16:51:21.301 W/dalvikvm(31571): Link of class &#39;LxxxMain;&#39; failed  修改方法很简单，把那个无用的abstract关键字去掉就好了。
记录一下。</description>
    </item>
    
    <item>
      <title>Jenkins单工程跨多代码目录</title>
      <link>/posts/jenkins-with-multi-svn-paths/</link>
      <pubDate>Thu, 13 Nov 2014 02:27:24 +0000</pubDate>
      
      <guid>/posts/jenkins-with-multi-svn-paths/</guid>
      <description>偶尔会遇到这种情况，例如工程A，工程B，同时依赖工程C（公共库）
而一般情况下，如果代码结构管理的好，工程C的svn（git）路径和工程A/B是完全分开的。
编译的时候正常导入（其实Android studio这里是有坑的，index无法排除目录）就好了。而Jenkins就需要特别配置一下。
增加对应的工程（这里使用的svn module是Subversion Release），如下：
（BTW，注意Local module directory，最好和本地代码路径保持一致，不然按照工程目录下的project.properties找不到对应工程就呵呵了）
这时候会发现，环境变量$SVN_REVISION很可能不干活了。
翻了下文档：
 Subversion Revision and URL information as Environment Variables
The Subversion SCM plugin exports the svn revisions and URLs of the build&amp;rsquo;s subversion modules as environment variables. These are $SVN_REVISION_n and $SVN_URL_n, where n is the 1-based index of the module in the configuration.
For backwards compatibility if there&amp;rsquo;s only a single module, its values are also exported as $SVN_REVISION and $SVN_URL.</description>
    </item>
    
    <item>
      <title>关于Android如何动态加载res</title>
      <link>/posts/about-loading-res-from-apk-directly/</link>
      <pubDate>Fri, 07 Nov 2014 03:15:58 +0000</pubDate>
      
      <guid>/posts/about-loading-res-from-apk-directly/</guid>
      <description>最近抽时间看了一下android插件化的东西。
也稍微研究了一下。总结一下权当记录。
同时也把研究过程中的testbed上传到github了，造福后人吧。
####为什么需要插件化？
最简单的原因大概就是为了避免过大的体积（rom size），以加速下载和安装。
更多的原因例如插件化后可以单独升级避免每次一个小改动就app体量的升级，为了针对不同区域不同用户做不同的适配，为了市场更高的单app评分（插件的差评不算主app中）等等。
####哪些可以插件化？
大部分的功能性代码/资源及非自定义的布局
####可用插件化方案： 这里仅讨论：以apk（在插件化的前提下，相比较jar，apk要灵活的多）的形式插件化的方案。
这里不讨论：自行定义数据格式，并自行实现解析器（parser或LayoutInflater）的方案。（因为造这种轮子总让我想起曾经一个叫XXUI的垃圾框架。。。）
 已安装插件apk的情况下：
 读取静态资源（如png/jpg等） 可以通过AIDL的方式直接获取，这里不赘述。
 读取并执行功能函数： 同上。参数不可序列化的情况，可参考下面“不安装插件apk的情况”
 读取布局 简单布局同上，自定义布局不确定是否可行（不过已经安装了，这就不重要了）。
 直接启动activity 因为已安装，所以直接intent去start acitivty即可。
  未安装插件apk的情况下：
 读取静态资源（如png/jpg等）
例如从包名com.example.plugin里，读取名为test的drawable资源
String libPath = Environment.getExternalStorageDirectory() + &amp;quot;/Plugin.apk&amp;quot;; try { AssetManager assetManager = AssetManager.class.newInstance(); Method addAssetPath = assetManager.getClass().getMethod( &amp;quot;addAssetPath&amp;quot;, String.class); addAssetPath.invoke(assetManager, libPath); mAssetManager = assetManager; } catch (Exception e) { e.printStackTrace(); } Resources superRes = super.getResources(); mResources = new Resources(mAssetManager, superRes.</description>
    </item>
    
    <item>
      <title>优化RGB-&gt;YUV</title>
      <link>/posts/optimize-rgb-to-yuv/</link>
      <pubDate>Sat, 11 Oct 2014 09:27:07 +0000</pubDate>
      
      <guid>/posts/optimize-rgb-to-yuv/</guid>
      <description>网上随处可见YUV到RGB的优化，其中被借鉴最多的应该就是VP8的源码了吧：
// Copyright 2010 Google Inc. // // This code is licensed under the same terms as WebM: // Software License Agreement: http://www.webmproject.org/license/software/ // Additional IP Rights Grant: http://www.webmproject.org/license/additional/ // ----------------------------------------------------------------------------- // // YUV-&amp;gt;RGB conversion function // // Author: Skal (pascal.massimino@gmail.com) #include &amp;quot;yuv.h&amp;quot; #if defined(__cplusplus) || defined(c_plusplus) extern &amp;quot;C&amp;quot; { #endif enum { YUV_HALF = 1 &amp;lt;&amp;lt; (YUV_FIX - 1) }; int16_t VP8kVToR[256], VP8kUToB[256]; int32_t VP8kVToG[256], VP8kUToG[256]; uint8_t VP8kClip[YUV_RANGE_MAX - YUV_RANGE_MIN]; static int done = 0; void VP8YUVInit() { int i; if (done) { return; } for (i = 0; i &amp;lt; 256; ++i) { VP8kVToR[i] = (89858 * (i - 128) + YUV_HALF) &amp;gt;&amp;gt; YUV_FIX; VP8kUToG[i] = -22014 * (i - 128) + YUV_HALF; VP8kVToG[i] = -45773 * (i - 128); VP8kUToB[i] = (113618 * (i - 128) + YUV_HALF) &amp;gt;&amp;gt; YUV_FIX; } for (i = YUV_RANGE_MIN; i &amp;lt; YUV_RANGE_MAX; ++i) { const int k = ((i - 16) * 76283 + YUV_HALF) &amp;gt;&amp;gt; YUV_FIX; VP8kClip[i - YUV_RANGE_MIN] = (k &amp;lt; 0) ?</description>
    </item>
    
    <item>
      <title>Ghost图片上传大小限制</title>
      <link>/posts/ghost-image-upload-limitation/</link>
      <pubDate>Thu, 09 Oct 2014 06:37:34 +0000</pubDate>
      
      <guid>/posts/ghost-image-upload-limitation/</guid>
      <description>Ghost通过ctrl+shift+i的华丽方式上传图片，会遇到一些问题。例如较大的图片上传，会报错。（大于1M）
由于一般架在VPS上的ghost都不是直接监听80端口，而是用nginx做前端转发；
所以推测八成被nginx限制住了。（可以参考ghost论坛）
nginx这边可以如下修改（老版本是在nginx.conf里面修改，那个波及面太广）：
直接修改site-enabled目录下面对应的站点config文件，在location /下面增加
 client_max_body_size 5m;
 即可（这里限制为最大5M，土豪随便改哈）。
重启nginx再试试～
Tada～</description>
    </item>
    
    <item>
      <title>Ghost修改圆框logo</title>
      <link>/posts/optimize-layout-of-ghost-logo/</link>
      <pubDate>Tue, 30 Sep 2014 04:22:52 +0000</pubDate>
      
      <guid>/posts/optimize-layout-of-ghost-logo/</guid>
      <description>我一直觉得Casper主题（就是默认的！LOL~）什么都不错，就是logo位置如果可以居中。。然后可以做一个圆形的效果。。。 就更好啦～～～
找了一个有类似实现的主题（ichi），对比了一下css（其实是搜了一下&amp;rdquo;logo&amp;rdquo;的css不同），然后用下面的方式解决：
.blog-logo img { width: 100px; height: 100px; border: 2px solid white; -webkit-border-radius: 100px; -moz-border-radius: 100px; -ms-border-radius: 100px; -o-border-radius: 100px; border-radius: 100px; }  替换完以后瞬间高大上了～
试一下分辨率发现几个小问题，把assets/css/screen.css中对应blog-logo的其他项清(delete)一下～
为了居中的话，修改blog-logo的float：left改为center即可
至于位置的话，修改index.hbs就可以了（把blog-logo移到page-title前面即可～）
最后就是主页的效果啦～
Tada～</description>
    </item>
    
    <item>
      <title>关于FFmpeg（基础）</title>
      <link>/posts/about-ffmpeg-basic/</link>
      <pubDate>Mon, 29 Sep 2014 12:35:21 +0000</pubDate>
      
      <guid>/posts/about-ffmpeg-basic/</guid>
      <description>这篇title有点大，因为ffmpeg作为一个合格的多媒体框架，支持那么多codec和协议，一篇文章想写完，不现实。
不过本着本人不喜细节的一贯作风（不要在意这些细节！），所以就这么随便说说吧，当是个给自己的记录。
（下文基本是自问自答的方式（原因在于我觉得这种风格蛮容易理解的））
####什么是FFmpeg？
这个太宽泛了，简单回答就是一个多媒体框架。什么是多媒体？一句话：但凡不是文字还具有表意的数据形式，都可以称之为多媒体。（不过，如果对多媒体真是一点概念都没有的话。。。建议还是出门左拐6块钱麻辣烫填饱肚子再说吧。。。）
 FFmpeg is the leading multimedia framework, able to decode, encode, transcode, mux, demux, stream, filter and play pretty much anything that humans and machines have created. It supports the most obscure ancient formats up to the cutting edge. No matter if they were designed by some standards committee, the community or a corporation.
FFmpeg是多媒体框架的领军人物，允许解码、编码、转码、Mux（觉得确实没有特别好的翻译）、Demux、stream（这里不是名词）、filter和播放各种文件。它还支持时至今日的绝大多数古老文件格式，即使那格式甚至都尚未成为标准。
 是不是听起来碉堡了。BUT有一点一定要了解的就是，FFmpeg的开源协议。
####听起来很棒，谁在用？
这个很难回答。。。
因为应用太广泛了，而且目前的FFmpeg版本（2.x）框架也更易于“组合”
所以更容易以不同的形式出现在你的周围。例如各种XX影音和XX视频等等。
####这么多，太棒了！那他们都开源了吧！
呵呵。
尽管LGPL已经比较宽泛，动态链接即可；
但是加上遵循GPL的X264这块烫手山芋，（其实还是有办法绕过的，在FFmpeg的开源协议有提到华丽的classpath exception）</description>
    </item>
    
    <item>
      <title>关于GPL</title>
      <link>/posts/about-gpl/</link>
      <pubDate>Wed, 24 Sep 2014 02:28:22 +0000</pubDate>
      
      <guid>/posts/about-gpl/</guid>
      <description>因为最近在做ffmpeg相关的东西，所以GPL/LGPL还是要了解一下的。
GPL的WIKI： GPL WIKI
FFmpeg主要代码遵循的是LGPL；简单来说，静态库调用的话必须同样遵循LGPL（被传染），而动态库调用就没关系：FFmpeg legal
 The following is a checklist for LGPL compliance when linking against the FFmpeg libraries. It is not the only way to comply with the license, but we think it is the easiest. There are also a few items that are not really related to LGPL compliance but are good ideas anyway.
1.Compile FFmpeg without &amp;ldquo;&amp;ndash;enable-gpl&amp;rdquo; and without &amp;ldquo;&amp;ndash;enable-nonfree&amp;rdquo;.
2.Use dynamic linking (on windows, this means linking to dlls) for linking with FFmpeg libraries.</description>
    </item>
    
    <item>
      <title>Ghost在首页显示图片而非摘要</title>
      <link>/posts/ghost-display-post-images-on-home-page/</link>
      <pubDate>Mon, 22 Sep 2014 04:07:00 +0000</pubDate>
      
      <guid>/posts/ghost-display-post-images-on-home-page/</guid>
      <description>我就拿默认的Casper来说事吧。
老版本应该参考Display Post Images on home page就够了。but我在目前的版本0.5.1中，index.hbs中没发现对应项。。。
看了一下，发现换地儿了，在./partials/loop.hbs里，把post-excerpt项如下修改即可～
&amp;lt;section class=&amp;quot;post-excerpt&amp;quot;&amp;gt; &amp;lt;p&amp;gt;{{content words=&amp;quot;30&amp;quot;}} &amp;lt;a class=&amp;quot;read-more&amp;quot; href=&amp;quot;{{url}}&amp;quot;&amp;gt;more &amp;amp;raquo;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/section&amp;gt;  修改后接着restart ghost（*我用的forever， 随手写个shell重启所有ghost～ 简单易用O Yeah*）就好啦
最新版修改hbs后，貌似不用重启ghost就可以生效了～页面刷新即可～
Tada~
[更新 2015/1/6]
现在更新的版本可以直接使用{{image}}了，直接参考Display Post Images on home page即可 &amp;ndash; 这个页面更新啦～ 哈哈～</description>
    </item>
    
  </channel>
</rss>