<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Internet on Hello Friend</title>
    <link>/categories/internet/</link>
    <description>Recent content in Internet on Hello Friend</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 07 Mar 2015 10:58:42 +0000</lastBuildDate>
    
	<atom:link href="/categories/internet/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于Internet的基础</title>
      <link>/posts/about-internet-basis/</link>
      <pubDate>Sat, 07 Mar 2015 10:58:42 +0000</pubDate>
      
      <guid>/posts/about-internet-basis/</guid>
      <description>一直想找时间好好理清楚Internet的基础，例如协议栈、例如http、例如tcp等等，但一直没整理。
原因一个是这确实是自己的短板，知道的不少，但一直没有从上到下的整理过。
再就是互联网协议从底到上，点太多，经常抓瞎，不知从何谈起。
[BTW，本文尝试不用Q&amp;amp;A的方式来展开试试看~]
现在正好离职了，终于空了足够时间来整理一下~
google+wiki的时候，找到了此文（上，下），写的很浅显易懂。推荐~
加上wiki
上面引用的那位哥说了这么句话： &amp;gt;前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？
 回答是不需要，我们可以把IP数据包直接放进以太网数据包的&amp;rdquo;数据&amp;rdquo;部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。
 这句话说得很好，其实不管七层OSI，还是成为实际标准的四层tcp/ip协议栈，关键的就是这样一个层级间的再封装以保持的层级无关（独立）性。
这种无关性，才能保证整个行业，各自轻松愉快的向前发展，而不用过分关心协议外的耦合性。（有种回答“学计算机都会修电脑”这种问题的即视感。。。）
下图（拼图）描述了从主机A到主机B的网络拓扑，可以清晰看到层与层之间的关系，同层级之间的联系，不同层级的数据格式、协议等：
层级之间，以一种简单方式封装实现的层级无关的数据包结构，wiki的原话相当到位：沿着不同的层应用数据的封装递减： （当然，过分简单也就意味着无法兼顾安全。）
想象下你是如何从主机A访问到这里的（类似的例子其实在下有提到）[这里会做很多简化]
 主机A首先用浏览器；输入nobodycare.me，敲回车；（这里忽略浏览器缓存等优化）
 浏览器会先去问dns服务器（一般DHCP会同样告知DNS服务器的IP），请求nobodycare.me的实际IP地址；
 DNS回复实际IP地址X（最初的GFW就是简单的DNS劫持/污染）；
 浏览器（这里跳过子网掩码这一步）通过主机A的端口N（1024-65535的某端口）向地址X的80端口（http）发出请求（request）；
 浏览器发出的请求的数据包（假设是TCP包），最终会如下分包：（TCP-&amp;gt;IP-&amp;gt;Ethernet） （这里说“分包”其实有一些歧义，因为TCP-&amp;gt;IP-&amp;gt;Ethernet的过程是不断加不同层报头的逐级封装递增，只是最后受限于ethernet的长度限制，才需要”分包“）
 请求经过多层路由，到达了地址X的这台主机B（一般称为服务器），再经过合包（Ethernet-&amp;gt;IP-&amp;gt;TCP），得到那个最初浏览器发出的请求；
 服务器开始处理这个请求：nginx转发-&amp;gt;node.js+ghost处理并反馈（response）html数据；
 反馈也一样进行分包（TCP-&amp;gt;IP-&amp;gt;Ethernet）；
 这分包后的反馈同样经过多层路由，返回到主机A并同样合包（Ethernet-&amp;gt;IP-&amp;gt;TCP），然后数据回到端口N；
 浏览器通过端口N收到反馈（html数据），并开始按照html数据进行渲染；
 然后主机A的浏览器就显示了本站；
  再回去看那个网络拓扑（如Application层：浏览器 -&amp;gt; node.js），就更加清晰明了了。
上面这个例子也简单描述了request/response模型
顺便提一下，http协议是无状态协议，服务器甚至都不知道两次http请求是不是相互有关联，这其实并不适合大部分的业务逻辑，这时候就需要一种方式来“记录（保持）”状态 &amp;ndash; Cookies和Session。  &amp;gt;客户端与服务器进行动态交互的Web应用程序出现之后，HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是Cookie，而另一个则是Session。HTTP本身是一个无状态的连接协议，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。
正是基于这一整套简单又很聪明的设计，构成了整个internet的基础。
简单又干活。（码农毕生追求了吧~）
在wiki里同时看到这么一段有趣的历史（这才让我想起来确实曾有一些高昂的专用网络）：
在长期的发展过程中，IP逐渐取代其他网络。这里是一个简单的解释。IP传输通用数据。数据能够用于任何目的，并且能够很轻易地取代以前由专有数据网络传输的数据。下面是一个普通的过程：
 一个专有的网络开发出来用于特定目的。如果它工作很好，用户将接受它。 为了便利提供IP服务，经常用于访问电子邮件或者聊天，通常以某种方式通过专有网络隧道实现。隧道方式最初可能非常没有效率，因为电子邮件和聊天只需要很低的带宽。 通过一点点的投资IP基础设施逐渐在专有数据网络周边出现。 用IP取代专有服务的需求出现，经常是一个用户要求。 IP替代品过程遍布整个因特网，这使IP替代品比最初的专有网络更加有价值（由于网络效应）。 专有网络受到压制。许多用户开始维护使用IP替代品的复制品。 IP包的间接开销很小，少于1%，这样在成本上非常有竞争性。人们开发一种能够将 IP带到专有网络上的大部分用户的不昂贵的传输媒介。 大多数用户为了削减开销，专有网络被取消。  新工作、新生活即将开始，就拿IP取代专属网络这种屌丝气死高富帅的故事来励志吧~</description>
    </item>
    
  </channel>
</rss>